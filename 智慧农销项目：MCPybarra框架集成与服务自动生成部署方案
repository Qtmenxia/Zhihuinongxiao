# 智慧农销项目：MCPybarra框架集成与服务自动生成部署方案

**基于用户输入自动生成并部署MCP服务的完整技术架构，实现农户产品信息到智能服务的端到端流程。**

MCPybarra是一个新型多智能体框架，能够从自然语言需求自动生成高质量的MCP服务。该框架已在ICSOC 2025发表，官方代码库位于 https://github.com/poutonwu/MCPybarra。其核心优势在于通过三个专门化代理协作，以**$0.018-0.14/服务**的成本，在**72%的任务**中超越人工编写的服务质量。

---

## MCPybarra框架核心架构

MCPybarra采用**三智能体协作**模式，在LangGraph状态图中运行迭代优化流程：

**Code Generator（代码生成器）** 接收自然语言需求，生成初始MCP服务代码。**Quality Assurance Inspector（质量检查器）** 使用五维评估体系对代码进行客观评分，重点考察安全性、健壮性、功能正确性、可维护性和性能。**Code Refiner（代码优化器）** 根据质检反馈进行定向改进，循环迭代直至通过质量门控。

框架的状态流转遵循"生成→评估→优化→再评估"的闭环模式。当所有质量维度分数达到阈值或达到最大迭代次数时，输出最终的高质量MCP服务代码。

---

## LangGraph工作流的ainvoke调用方式

`ainvoke` 是LangGraph中执行异步工作流的核心方法。其完整签名和关键参数如下：

```python
async def ainvoke(
    input: InputT | Command | None,        # 输入状态字典
    config: RunnableConfig | None = None,   # 运行配置
    context: ContextT | None = None,        # 静态上下文（v0.6.0+）
    stream_mode: StreamMode = "values",     # 输出模式
    **kwargs: Any
) -> dict[str, Any] | Any
```

当 `stream_mode="values"` 时（默认），返回**完整的最终状态字典**；否则返回输出块列表。对于MCPybarra工作流，典型调用模式为：

```python
from langgraph.graph import StateGraph, START, END
from typing import TypedDict

class MCPybarraState(TypedDict):
    requirements: str           # 自然语言需求输入
    generated_code: str         # 当前代码版本
    quality_scores: dict        # 五维评估结果
    iteration_count: int        # 迭代计数
    final_output: str           # 最终MCP服务代码

# 构建并编译工作流图
mcpybarra_workflow = builder.compile()

async def generate_mcp_service(product_requirements: str):
    initial_state = {
        "requirements": product_requirements,
        "generated_code": "",
        "quality_scores": {},
        "iteration_count": 0,
        "final_output": ""
    }
    result = await mcpybarra_workflow.ainvoke(initial_state)
    return result["final_output"]  # 返回生成的MCP服务代码
```

批量处理使用 `abatch` 方法，支持并行生成多个服务。

---

## 后端服务管理器设计（service_manager.py）

服务管理器负责MCP服务的完整生命周期管理，核心功能包括服务部署、启停控制和健康监测：

```python
class MCPServiceManager:
    def __init__(self, services_dir: Path):
        self.services_dir = services_dir
        self.running_services: dict[str, subprocess.Popen] = {}
    
    async def deploy_service(self, service_code: str, config: MCPServiceConfig):
        """部署生成的MCP服务代码"""
        service_path = self.services_dir / config.name
        service_path.mkdir(parents=True, exist_ok=True)
        
        # 写入生成的服务代码
        (service_path / "server.py").write_text(service_code)
        (service_path / "requirements.txt").write_text("mcp[cli]\n")
        
        # 安装依赖并启动服务
        subprocess.run(["pip", "install", "-r", "requirements.txt"], cwd=service_path)
        return await self.start_service(config)
    
    async def start_service(self, config: MCPServiceConfig) -> bool:
        """启动MCP服务进程"""
        process = subprocess.Popen(
            ["python", "server.py"],
            cwd=str(self.services_dir / config.name),
            env={**os.environ, **config.env_vars}
        )
        self.running_services[config.name] = process
        return True
    
    async def get_service_status(self, name: str) -> ServiceStatus:
        """检查服务运行状态"""
        if name not in self.running_services:
            return ServiceStatus.STOPPED
        return ServiceStatus.RUNNING if self.running_services[name].poll() is None else ServiceStatus.ERROR
```

对于生产环境，建议使用Docker容器化部署，配合健康检查和自动重启机制。

---

## 数据模型定义（models/）

MCP服务的核心数据模型需要追踪工具、资源、提示词三类原语及部署状态：

```python
class MCPService(Base):
    __tablename__ = "mcp_services"
    
    id = Column(Integer, primary_key=True)
    name = Column(String(255), unique=True, nullable=False)
    description = Column(String(1000))
    
    # MCP三原语（JSON存储）
    tools = Column(JSON, default=list)      # 可执行工具定义
    resources = Column(JSON, default=list)   # 只读数据资源
    prompts = Column(JSON, default=list)     # 提示词模板
    
    # 部署配置
    status = Column(Enum(ServiceStatus), default=ServiceStatus.DRAFT)
    port = Column(Integer)
    transport = Column(String(50), default="streamable-http")
    
    # 生成代码存储
    code_path = Column(String(500))
    docker_image = Column(String(255))
    
    # 元数据
    created_at = Column(DateTime, default=datetime.utcnow)
    is_healthy = Column(Boolean, default=True)
```

Pydantic Schema用于API请求验证，确保农户提交的产品信息格式正确。

---

## API路由设计（routers/）

FastAPI路由实现服务的CRUD操作和部署控制：

```python
router = APIRouter(prefix="/api/v1/services", tags=["MCP Services"])

@router.post("/generate", response_model=GenerationJobResponse)
async def generate_mcp_service(
    product_info: ProductInfo,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db)
):
    """从农户产品信息生成MCP服务"""
    # 创建生成任务
    job = GenerationJob(
        product_name=product_info.name,
        requirements=build_requirements(product_info),
        status="pending"
    )
    db.add(job)
    db.commit()
    
    # 后台执行MCPybarra生成流程
    background_tasks.add_task(
        run_mcpybarra_generation,
        job.id, product_info, db
    )
    return {"job_id": job.id, "status": "pending"}

@router.post("/{service_id}/deploy")
async def deploy_service(service_id: int, background_tasks: BackgroundTasks):
    """部署生成的MCP服务"""
    service.status = ServiceStatus.DEPLOYING
    background_tasks.add_task(deploy_service_task, service_id)
    return {"status": "deploying"}

@router.get("/jobs/{job_id}/status")
async def get_job_status(job_id: int):
    """获取生成任务状态（支持前端轮询）"""
    return {"status": job.status, "progress": job.progress}
```

---

## Vue前端架构（farmer-admin/）

农户管理前端采用Vue 3 + Pinia + Axios的标准架构：

```
frontend/farmer-admin/
├── src/
│   ├── api/              # API服务层
│   │   └── mcpService.js
│   ├── components/       # 可复用组件
│   │   └── ProductForm.vue
│   ├── views/            # 页面组件
│   │   ├── ProductInput.vue
│   │   └── ServiceStatus.vue
│   ├── stores/           # Pinia状态管理
│   │   └── mcpJobs.js
│   └── composables/      # 组合式函数
│       └── useJobPolling.js
```

产品信息提交和状态追踪的核心实现：

```javascript
// stores/mcpJobs.js
export const useMcpJobStore = defineStore('mcpJobs', {
  state: () => ({
    currentJob: null,
    loading: false
  }),
  
  actions: {
    async submitProductForGeneration(productData) {
      this.loading = true;
      const { data } = await axios.post('/api/v1/services/generate', {
        name: productData.name,
        description: productData.description,
        category: productData.category,
        price: productData.price,
        origin: productData.origin
      });
      this.currentJob = data;
      return data.job_id;
    }
  }
});
```

长时任务状态使用轮询或WebSocket追踪：

```javascript
// composables/useJobPolling.js
export function useJobPolling(jobId, interval = 2000) {
  const status = ref('pending');
  const progress = ref(0);
  
  const poll = async () => {
    const { data } = await axios.get(`/api/v1/services/jobs/${jobId}/status`);
    status.value = data.status;
    progress.value = data.progress;
    
    if (data.status === 'completed' || data.status === 'failed') {
      clearInterval(pollTimer);
    }
  };
  
  onMounted(() => { pollTimer = setInterval(poll, interval); });
  return { status, progress };
}
```

---

## 完整的服务生成部署流程

从前端农户输入到MCP服务上线的端到端流程分为**四个阶段**：

**第一阶段：产品信息收集** 
农户通过Vue前端表单输入产品名称、类别、价格、产地、描述等信息。表单数据验证通过后，通过Axios提交至后端API。

**第二阶段：需求转换与代码生成**
后端将产品信息转换为自然语言需求描述，调用MCPybarra工作流的 `ainvoke` 方法。三个智能体协作生成符合质量标准的MCP服务代码，整个过程在后台任务中异步执行。

**第三阶段：服务部署**
生成的代码写入服务目录，安装依赖后启动MCP服务进程（或构建Docker容器）。服务管理器注册新服务，分配端口，更新数据库状态。

**第四阶段：运行与监控**
服务以 `streamable-http` 传输协议对外暴露工具端点。健康检查定期探测服务状态，异常时自动重启。农户可在前端查看服务状态、访问端点URL。

---

## 技术栈选择建议

| 层级 | 推荐技术 | 说明 |
|------|----------|------|
| 前端 | Vue 3 + Pinia + Element Plus | 响应式表单，状态管理，组件库 |
| 后端框架 | FastAPI | 异步支持，自动文档，类型验证 |
| 工作流引擎 | LangGraph | 状态图管理，条件路由，迭代支持 |
| 代码生成 | MCPybarra | 三智能体协作，质量门控 |
| MCP服务 | FastMCP | Python MCP SDK，简化服务开发 |
| 部署 | Docker + Docker Compose | 容器隔离，编排管理 |
| 数据库 | PostgreSQL + SQLAlchemy | 关系存储，ORM支持 |

---

## 关键实现注意事项

MCPybarra的迭代次数需要合理设置上限（建议3-5次），避免无限循环。每次迭代成本约$0.01，总成本控制在$0.14以内为宜。生成的代码应在沙箱环境中验证后再部署。

前端轮询间隔建议**2-3秒**，WebSocket更适合需要实时反馈的场景。生成任务通常需要**30秒至2分钟**，应提供进度条和阶段提示。

MCP服务端口需要动态分配并避免冲突。生产环境使用反向代理（Nginx）统一入口，配合SSL/TLS加密。Docker部署时需配置健康检查和资源限制。

该架构可扩展支持多租户场景，为每个农户隔离服务命名空间，实现从产品录入到智能服务上线的全自动化流程。