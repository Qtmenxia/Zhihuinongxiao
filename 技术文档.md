# 智农链销 - 工程落地技术方案

## 项目概述

**智农链销**是基于MCPybarra多智能体框架的AI农产品电商赋能平台，核心目标是让农户/合作社通过自然语言描述即可生成专属电商服务，实现零门槛接入电商平台。

### 核心业务场景
- **首批落地产品**: 山西蒲县被子垣有机果园
- **产品品类**: 玉露香梨、维纳斯黄金苹果、蒲香红苹果、烟富苹果
- **价格区间**: 79-168元 (家庭装/礼盒装)
- **合作方**: 中国农业大学科技小院 + 蒲县农业资源开发中心

---

## 一、系统架构设计

### 1.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                              智农链销平台                                 │
├─────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐                  │
│  │  农户前端    │    │  管理后台    │    │  小程序/H5  │   用户层         │
│  │ (Vue3+TS)   │    │ (Vue3+TS)   │    │ (uni-app)  │                  │
│  └──────┬──────┘    └──────┬──────┘    └──────┬──────┘                  │
│         │                  │                  │                         │
│         └──────────────────┼──────────────────┘                         │
│                            ▼                                            │
│  ┌─────────────────────────────────────────────────────────────┐        │
│  │                    API Gateway (FastAPI)                     │   网关  │
│  │        认证/限流/路由/日志/监控                                │        │
│  └─────────────────────────┬───────────────────────────────────┘        │
│                            ▼                                            │
│  ┌─────────────────────────────────────────────────────────────┐        │
│  │                     MCP Server集群                           │        │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐       │  服务层 │
│  │  │商品管理   │ │订单管理   │ │智能客服   │ │库存管理   │       │        │
│  │  │MCP Server│ │MCP Server│ │MCP Server│ │MCP Server│       │        │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘       │        │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐       │        │
│  │  │平台接入   │ │溯源追踪   │ │数据统计   │ │营销推广   │       │        │
│  │  │MCP Server│ │MCP Server│ │MCP Server│ │MCP Server│       │        │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘       │        │
│  └─────────────────────────┬───────────────────────────────────┘        │
│                            ▼                                            │
│  ┌─────────────────────────────────────────────────────────────┐        │
│  │                   MCPybarra生成引擎                          │  生成层 │
│  │  ┌────────────┐ ┌────────────┐ ┌────────────┐              │        │
│  │  │Code        │ │QA          │ │Code        │              │        │
│  │  │Generator   │→│Inspector   │→│Refiner     │              │        │
│  │  │Agent       │ │Agent       │ │Agent       │              │        │
│  │  └────────────┘ └────────────┘ └────────────┘              │        │
│  └─────────────────────────┬───────────────────────────────────┘        │
│                            ▼                                            │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐          数据层    │
│  │PostgreSQL│ │  Redis   │ │   MinIO  │ │   MQ     │                   │
│  │(业务数据) │ │(缓存/会话)│ │(文件存储) │ │(消息队列) │                   │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘                   │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 技术栈选型

| 层级 | 技术选型 | 说明 |
|------|----------|------|
| 前端 | Vue 3 + TypeScript + Vite | 管理后台、农户端 |
| 移动端 | uni-app (Vue3) | 小程序、H5、APP多端复用 |
| API网关 | FastAPI + Uvicorn | 高性能异步框架 |
| MCP服务 | Python + mcp库 | Model Context Protocol标准实现 |
| AI生成 | MCPybarra + LangGraph | 多智能体MCP服务生成 |
| LLM | DeepSeek-V3 / Qwen-Max | 性价比最优 |
| 数据库 | PostgreSQL 16 | 主数据存储 |
| 缓存 | Redis 7 | 会话、热点数据 |
| 文件存储 | MinIO | 图片、文档存储 |
| 消息队列 | RabbitMQ | 异步任务、事件驱动 |
| 容器化 | Docker + Docker Compose | 开发和部署 |
| 监控 | Prometheus + Grafana | 系统监控 |

---

## 二、核心MCP服务设计

### 2.1 MCP服务列表

| 服务名称 | 功能描述 | 优先级 |
|----------|----------|--------|
| product-management | 商品CRUD、SKU管理、定价策略 | P0 |
| order-management | 订单创建、状态流转、退款处理 | P0 |
| inventory-management | 库存查询、预警、批次管理 | P0 |
| smart-customer-service | AI智能客服、FAQ自动回复 | P1 |
| platform-connector | 淘宝/拼多多/抖音API对接 | P1 |
| traceability | 农产品溯源、二维码生成 | P2 |
| analytics | 销售统计、报表生成 | P2 |
| marketing | 优惠券、促销活动管理 | P2 |

### 2.2 商品管理MCP服务示例

```python
# mcp_servers/product_management/server.py
"""
商品管理MCP服务
功能：商品CRUD、SKU管理、库存同步
"""

import json
import asyncio
from datetime import datetime
from typing import Optional, List
from decimal import Decimal

from mcp.server import Server
from mcp.types import Tool, TextContent
from pydantic import BaseModel, Field
import asyncpg

# ============ 数据模型 ============

class ProductSKU(BaseModel):
    """商品SKU模型"""
    sku_id: str = Field(..., description="SKU唯一标识")
    product_id: str = Field(..., description="所属商品ID")
    name: str = Field(..., description="SKU名称，如：天地盖礼盒-9枚装")
    fruit_type: str = Field(..., description="水果类型：玉露香梨/维纳斯苹果/蒲香红/烟富")
    package_type: str = Field(..., description="包装类型：天地盖礼盒/手提礼盒/对开箱子")
    grade: str = Field(..., description="等级：一级/二级/不套袋")
    spec_per_box: int = Field(..., description="每箱规格（枚）")
    fruit_size: str = Field(..., description="果子规格，如：85-95")
    net_weight_with_box: float = Field(..., description="含箱净重(斤)")
    net_weight_fruit: float = Field(..., description="果子净重(斤)")
    price: Decimal = Field(..., description="零售价（元）")
    cost_price: Optional[Decimal] = Field(None, description="成本价")
    stock: int = Field(default=0, description="库存数量")
    status: str = Field(default="active", description="状态：active/inactive/sold_out")

class Product(BaseModel):
    """商品主模型"""
    product_id: str = Field(..., description="商品唯一标识")
    farmer_id: str = Field(..., description="农户ID")
    name: str = Field(..., description="商品名称")
    category: str = Field(..., description="品类：有机水果/深加工产品")
    description: str = Field(..., description="商品描述")
    origin: str = Field(default="山西蒲县被子垣", description="产地")
    certification: str = Field(default="有机认证", description="认证信息")
    images: List[str] = Field(default_factory=list, description="商品图片URL列表")
    skus: List[ProductSKU] = Field(default_factory=list, description="SKU列表")
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)

# ============ 数据库连接 ============

class DatabasePool:
    """数据库连接池管理"""
    _pool: Optional[asyncpg.Pool] = None
    
    @classmethod
    async def get_pool(cls) -> asyncpg.Pool:
        if cls._pool is None:
            cls._pool = await asyncpg.create_pool(
                host="localhost",
                port=5432,
                user="postgres",
                password="postgres",
                database="zhinonglianxiao",
                min_size=5,
                max_size=20
            )
        return cls._pool
    
    @classmethod
    async def close(cls):
        if cls._pool:
            await cls._pool.close()

# ============ MCP Server定义 ============

server = Server("product-management")

@server.list_tools()
async def list_tools() -> List[Tool]:
    """列出所有可用工具"""
    return [
        Tool(
            name="create_product",
            description="创建新商品，包含基本信息和SKU",
            inputSchema={
                "type": "object",
                "properties": {
                    "farmer_id": {"type": "string", "description": "农户ID"},
                    "name": {"type": "string", "description": "商品名称"},
                    "category": {"type": "string", "description": "品类"},
                    "description": {"type": "string", "description": "商品描述"},
                    "fruit_type": {"type": "string", "description": "水果类型"},
                    "skus": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "properties": {
                                "package_type": {"type": "string"},
                                "grade": {"type": "string"},
                                "spec_per_box": {"type": "integer"},
                                "fruit_size": {"type": "string"},
                                "price": {"type": "number"},
                                "stock": {"type": "integer"}
                            }
                        },
                        "description": "SKU列表"
                    }
                },
                "required": ["farmer_id", "name", "category", "fruit_type"]
            }
        ),
        Tool(
            name="get_product",
            description="根据商品ID获取商品详情",
            inputSchema={
                "type": "object",
                "properties": {
                    "product_id": {"type": "string", "description": "商品ID"}
                },
                "required": ["product_id"]
            }
        ),
        Tool(
            name="list_products",
            description="查询商品列表，支持分页和筛选",
            inputSchema={
                "type": "object",
                "properties": {
                    "farmer_id": {"type": "string", "description": "农户ID（可选）"},
                    "category": {"type": "string", "description": "品类筛选"},
                    "fruit_type": {"type": "string", "description": "水果类型筛选"},
                    "page": {"type": "integer", "default": 1},
                    "page_size": {"type": "integer", "default": 20}
                }
            }
        ),
        Tool(
            name="update_product",
            description="更新商品信息",
            inputSchema={
                "type": "object",
                "properties": {
                    "product_id": {"type": "string", "description": "商品ID"},
                    "name": {"type": "string", "description": "商品名称"},
                    "description": {"type": "string", "description": "商品描述"},
                    "images": {"type": "array", "items": {"type": "string"}}
                },
                "required": ["product_id"]
            }
        ),
        Tool(
            name="update_sku_price",
            description="更新SKU价格",
            inputSchema={
                "type": "object",
                "properties": {
                    "sku_id": {"type": "string", "description": "SKU ID"},
                    "price": {"type": "number", "description": "新价格"}
                },
                "required": ["sku_id", "price"]
            }
        ),
        Tool(
            name="update_sku_stock",
            description="更新SKU库存",
            inputSchema={
                "type": "object",
                "properties": {
                    "sku_id": {"type": "string", "description": "SKU ID"},
                    "stock_change": {"type": "integer", "description": "库存变化量（正数增加，负数减少）"}
                },
                "required": ["sku_id", "stock_change"]
            }
        ),
        Tool(
            name="get_low_stock_skus",
            description="获取库存预警SKU列表",
            inputSchema={
                "type": "object",
                "properties": {
                    "farmer_id": {"type": "string", "description": "农户ID"},
                    "threshold": {"type": "integer", "default": 10, "description": "库存预警阈值"}
                },
                "required": ["farmer_id"]
            }
        ),
        Tool(
            name="batch_import_products",
            description="批量导入商品（从Excel/JSON）",
            inputSchema={
                "type": "object",
                "properties": {
                    "farmer_id": {"type": "string", "description": "农户ID"},
                    "products_data": {"type": "array", "description": "商品数据列表"}
                },
                "required": ["farmer_id", "products_data"]
            }
        )
    ]

@server.call_tool()
async def call_tool(name: str, arguments: dict) -> List[TextContent]:
    """执行工具调用"""
    pool = await DatabasePool.get_pool()
    
    try:
        if name == "create_product":
            return await _create_product(pool, arguments)
        elif name == "get_product":
            return await _get_product(pool, arguments)
        elif name == "list_products":
            return await _list_products(pool, arguments)
        elif name == "update_product":
            return await _update_product(pool, arguments)
        elif name == "update_sku_price":
            return await _update_sku_price(pool, arguments)
        elif name == "update_sku_stock":
            return await _update_sku_stock(pool, arguments)
        elif name == "get_low_stock_skus":
            return await _get_low_stock_skus(pool, arguments)
        elif name == "batch_import_products":
            return await _batch_import_products(pool, arguments)
        else:
            return [TextContent(type="text", text=f"未知工具: {name}")]
    except Exception as e:
        return [TextContent(type="text", text=f"执行错误: {str(e)}")]

# ============ 工具实现 ============

async def _create_product(pool: asyncpg.Pool, args: dict) -> List[TextContent]:
    """创建商品"""
    import uuid
    
    product_id = f"PRD_{uuid.uuid4().hex[:8]}"
    
    async with pool.acquire() as conn:
        async with conn.transaction():
            # 插入商品主表
            await conn.execute("""
                INSERT INTO products (product_id, farmer_id, name, category, description, fruit_type, origin, certification, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW(), NOW())
            """, product_id, args["farmer_id"], args["name"], args["category"], 
                args.get("description", ""), args["fruit_type"], 
                args.get("origin", "山西蒲县被子垣"), args.get("certification", "有机认证"))
            
            # 插入SKU
            skus = args.get("skus", [])
            for i, sku in enumerate(skus):
                sku_id = f"SKU_{product_id}_{i+1:02d}"
                sku_name = f"{args['fruit_type']}-{sku.get('package_type', '标准装')}-{sku.get('spec_per_box', 0)}枚装"
                
                await conn.execute("""
                    INSERT INTO product_skus (sku_id, product_id, name, fruit_type, package_type, grade, spec_per_box, fruit_size, net_weight_with_box, net_weight_fruit, price, stock, status)
                    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, 'active')
                """, sku_id, product_id, sku_name, args["fruit_type"],
                    sku.get("package_type", ""), sku.get("grade", "一级"),
                    sku.get("spec_per_box", 0), sku.get("fruit_size", ""),
                    sku.get("net_weight_with_box", 0), sku.get("net_weight_fruit", 0),
                    sku.get("price", 0), sku.get("stock", 0))
    
    return [TextContent(type="text", text=json.dumps({
        "success": True,
        "product_id": product_id,
        "message": f"商品创建成功，包含{len(skus)}个SKU"
    }, ensure_ascii=False))]

async def _get_product(pool: asyncpg.Pool, args: dict) -> List[TextContent]:
    """获取商品详情"""
    async with pool.acquire() as conn:
        product = await conn.fetchrow("""
            SELECT * FROM products WHERE product_id = $1
        """, args["product_id"])
        
        if not product:
            return [TextContent(type="text", text=json.dumps({
                "success": False, "error": "商品不存在"
            }, ensure_ascii=False))]
        
        skus = await conn.fetch("""
            SELECT * FROM product_skus WHERE product_id = $1 ORDER BY sku_id
        """, args["product_id"])
        
        result = dict(product)
        result["skus"] = [dict(sku) for sku in skus]
        # 处理datetime序列化
        for key, value in result.items():
            if isinstance(value, datetime):
                result[key] = value.isoformat()
        for sku in result["skus"]:
            for key, value in sku.items():
                if isinstance(value, (datetime, Decimal)):
                    sku[key] = str(value)
    
    return [TextContent(type="text", text=json.dumps({
        "success": True, "data": result
    }, ensure_ascii=False))]

async def _list_products(pool: asyncpg.Pool, args: dict) -> List[TextContent]:
    """查询商品列表"""
    page = args.get("page", 1)
    page_size = args.get("page_size", 20)
    offset = (page - 1) * page_size
    
    conditions = []
    params = []
    param_idx = 1
    
    if args.get("farmer_id"):
        conditions.append(f"farmer_id = ${param_idx}")
        params.append(args["farmer_id"])
        param_idx += 1
    
    if args.get("category"):
        conditions.append(f"category = ${param_idx}")
        params.append(args["category"])
        param_idx += 1
    
    if args.get("fruit_type"):
        conditions.append(f"fruit_type = ${param_idx}")
        params.append(args["fruit_type"])
        param_idx += 1
    
    where_clause = "WHERE " + " AND ".join(conditions) if conditions else ""
    
    async with pool.acquire() as conn:
        # 查询总数
        count_sql = f"SELECT COUNT(*) FROM products {where_clause}"
        total = await conn.fetchval(count_sql, *params)
        
        # 查询列表
        list_sql = f"""
            SELECT * FROM products {where_clause}
            ORDER BY created_at DESC
            LIMIT ${param_idx} OFFSET ${param_idx + 1}
        """
        params.extend([page_size, offset])
        products = await conn.fetch(list_sql, *params)
        
        result = []
        for p in products:
            item = dict(p)
            for key, value in item.items():
                if isinstance(value, (datetime, Decimal)):
                    item[key] = str(value)
            result.append(item)
    
    return [TextContent(type="text", text=json.dumps({
        "success": True,
        "data": result,
        "pagination": {
            "page": page,
            "page_size": page_size,
            "total": total,
            "total_pages": (total + page_size - 1) // page_size
        }
    }, ensure_ascii=False))]

async def _update_sku_stock(pool: asyncpg.Pool, args: dict) -> List[TextContent]:
    """更新库存"""
    async with pool.acquire() as conn:
        result = await conn.execute("""
            UPDATE product_skus 
            SET stock = stock + $1,
                status = CASE 
                    WHEN stock + $1 <= 0 THEN 'sold_out'
                    ELSE 'active'
                END
            WHERE sku_id = $2
        """, args["stock_change"], args["sku_id"])
        
        new_stock = await conn.fetchval("""
            SELECT stock FROM product_skus WHERE sku_id = $1
        """, args["sku_id"])
    
    return [TextContent(type="text", text=json.dumps({
        "success": True,
        "sku_id": args["sku_id"],
        "new_stock": new_stock,
        "message": f"库存更新成功，变化量: {args['stock_change']}"
    }, ensure_ascii=False))]

async def _get_low_stock_skus(pool: asyncpg.Pool, args: dict) -> List[TextContent]:
    """获取库存预警"""
    threshold = args.get("threshold", 10)
    
    async with pool.acquire() as conn:
        skus = await conn.fetch("""
            SELECT s.*, p.name as product_name, p.farmer_id
            FROM product_skus s
            JOIN products p ON s.product_id = p.product_id
            WHERE p.farmer_id = $1 AND s.stock <= $2 AND s.status = 'active'
            ORDER BY s.stock ASC
        """, args["farmer_id"], threshold)
        
        result = []
        for sku in skus:
            item = dict(sku)
            for key, value in item.items():
                if isinstance(value, (datetime, Decimal)):
                    item[key] = str(value)
            result.append(item)
    
    return [TextContent(type="text", text=json.dumps({
        "success": True,
        "warning_count": len(result),
        "threshold": threshold,
        "data": result
    }, ensure_ascii=False))]

# 其他工具实现省略...

# ============ 服务启动 ============

async def main():
    """启动MCP服务"""
    from mcp.server.stdio import stdio_server
    
    async with stdio_server() as (read_stream, write_stream):
        await server.run(read_stream, write_stream, server.create_initialization_options())

if __name__ == "__main__":
    asyncio.run(main())
```

### 2.3 订单管理MCP服务示例

```python
# mcp_servers/order_management/server.py
"""
订单管理MCP服务
功能：订单创建、状态管理、退款处理
"""

import json
import asyncio
from datetime import datetime
from typing import Optional, List
from decimal import Decimal
from enum import Enum

from mcp.server import Server
from mcp.types import Tool, TextContent
from pydantic import BaseModel, Field
import asyncpg

class OrderStatus(str, Enum):
    PENDING_PAYMENT = "pending_payment"      # 待付款
    PAID = "paid"                            # 已付款
    PENDING_SHIPMENT = "pending_shipment"    # 待发货
    SHIPPED = "shipped"                      # 已发货
    DELIVERED = "delivered"                  # 已送达
    COMPLETED = "completed"                  # 已完成
    CANCELLED = "cancelled"                  # 已取消
    REFUND_PENDING = "refund_pending"        # 退款中
    REFUNDED = "refunded"                    # 已退款

class OrderItem(BaseModel):
    sku_id: str
    product_name: str
    sku_name: str
    quantity: int
    unit_price: Decimal
    subtotal: Decimal

class Order(BaseModel):
    order_id: str
    farmer_id: str
    buyer_name: str
    buyer_phone: str
    shipping_address: str
    items: List[OrderItem]
    total_amount: Decimal
    shipping_fee: Decimal = Decimal("0")
    discount_amount: Decimal = Decimal("0")
    final_amount: Decimal
    status: OrderStatus
    platform: str  # taobao/pinduoduo/douyin/wechat/direct
    platform_order_id: Optional[str] = None
    tracking_number: Optional[str] = None
    remark: Optional[str] = None
    created_at: datetime
    paid_at: Optional[datetime] = None
    shipped_at: Optional[datetime] = None

server = Server("order-management")

@server.list_tools()
async def list_tools() -> List[Tool]:
    return [
        Tool(
            name="create_order",
            description="创建新订单",
            inputSchema={
                "type": "object",
                "properties": {
                    "farmer_id": {"type": "string", "description": "农户ID"},
                    "buyer_name": {"type": "string", "description": "买家姓名"},
                    "buyer_phone": {"type": "string", "description": "买家电话"},
                    "shipping_address": {"type": "string", "description": "收货地址"},
                    "items": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "properties": {
                                "sku_id": {"type": "string"},
                                "quantity": {"type": "integer"}
                            },
                            "required": ["sku_id", "quantity"]
                        },
                        "description": "订单商品列表"
                    },
                    "platform": {"type": "string", "enum": ["taobao", "pinduoduo", "douyin", "wechat", "direct"]},
                    "platform_order_id": {"type": "string", "description": "平台订单号（可选）"},
                    "discount_amount": {"type": "number", "description": "优惠金额"},
                    "remark": {"type": "string", "description": "备注"}
                },
                "required": ["farmer_id", "buyer_name", "buyer_phone", "shipping_address", "items", "platform"]
            }
        ),
        Tool(
            name="get_order",
            description="获取订单详情",
            inputSchema={
                "type": "object",
                "properties": {
                    "order_id": {"type": "string", "description": "订单ID"}
                },
                "required": ["order_id"]
            }
        ),
        Tool(
            name="list_orders",
            description="查询订单列表",
            inputSchema={
                "type": "object",
                "properties": {
                    "farmer_id": {"type": "string", "description": "农户ID"},
                    "status": {"type": "string", "description": "订单状态"},
                    "platform": {"type": "string", "description": "来源平台"},
                    "start_date": {"type": "string", "description": "开始日期(YYYY-MM-DD)"},
                    "end_date": {"type": "string", "description": "结束日期(YYYY-MM-DD)"},
                    "page": {"type": "integer", "default": 1},
                    "page_size": {"type": "integer", "default": 20}
                },
                "required": ["farmer_id"]
            }
        ),
        Tool(
            name="update_order_status",
            description="更新订单状态",
            inputSchema={
                "type": "object",
                "properties": {
                    "order_id": {"type": "string", "description": "订单ID"},
                    "status": {
                        "type": "string",
                        "enum": ["paid", "pending_shipment", "shipped", "delivered", "completed", "cancelled", "refund_pending", "refunded"],
                        "description": "新状态"
                    },
                    "tracking_number": {"type": "string", "description": "快递单号（发货时必填）"}
                },
                "required": ["order_id", "status"]
            }
        ),
        Tool(
            name="ship_order",
            description="订单发货",
            inputSchema={
                "type": "object",
                "properties": {
                    "order_id": {"type": "string", "description": "订单ID"},
                    "tracking_number": {"type": "string", "description": "快递单号"},
                    "shipping_company": {"type": "string", "description": "快递公司", "default": "顺丰速运"}
                },
                "required": ["order_id", "tracking_number"]
            }
        ),
        Tool(
            name="cancel_order",
            description="取消订单",
            inputSchema={
                "type": "object",
                "properties": {
                    "order_id": {"type": "string", "description": "订单ID"},
                    "reason": {"type": "string", "description": "取消原因"}
                },
                "required": ["order_id", "reason"]
            }
        ),
        Tool(
            name="process_refund",
            description="处理退款",
            inputSchema={
                "type": "object",
                "properties": {
                    "order_id": {"type": "string", "description": "订单ID"},
                    "refund_amount": {"type": "number", "description": "退款金额"},
                    "reason": {"type": "string", "description": "退款原因"}
                },
                "required": ["order_id", "refund_amount", "reason"]
            }
        ),
        Tool(
            name="get_order_statistics",
            description="获取订单统计数据",
            inputSchema={
                "type": "object",
                "properties": {
                    "farmer_id": {"type": "string", "description": "农户ID"},
                    "start_date": {"type": "string", "description": "开始日期"},
                    "end_date": {"type": "string", "description": "结束日期"},
                    "group_by": {"type": "string", "enum": ["day", "week", "month"], "default": "day"}
                },
                "required": ["farmer_id"]
            }
        )
    ]

@server.call_tool()
async def call_tool(name: str, arguments: dict) -> List[TextContent]:
    """执行工具调用"""
    # 实现逻辑与商品管理类似
    pass

async def main():
    from mcp.server.stdio import stdio_server
    async with stdio_server() as (read_stream, write_stream):
        await server.run(read_stream, write_stream, server.create_initialization_options())

if __name__ == "__main__":
    asyncio.run(main())
```

### 2.4 智能客服MCP服务示例

```python
# mcp_servers/smart_customer_service/server.py
"""
智能客服MCP服务
功能：自动回复、FAQ管理、人工转接
"""

import json
import asyncio
from datetime import datetime
from typing import List, Optional

from mcp.server import Server
from mcp.types import Tool, TextContent
import asyncpg
from openai import AsyncOpenAI

server = Server("smart-customer-service")

# FAQ知识库（可存入数据库）
FAQ_KNOWLEDGE_BASE = {
    "发货时间": "我们的有机水果从蒲县基地现摘现发，下单后1-2天内发货，顺丰速运全程冷链，3-5天送达。",
    "保质期": "鲜果建议收到后冷藏保存，可保鲜7-10天。常温下建议3-5天内食用最佳。",
    "有机认证": "我们的水果来自山西蒲县被子垣有机果园，位于北纬36度黄金果业带，通过国家有机认证，坚持不使用化肥和农药。",
    "退换货": "如收到水果有破损或品质问题，请在签收后24小时内联系我们，提供照片凭证，我们支持退款或补发。",
    "包装规格": "我们提供两种包装：天地盖礼盒（9-12枚/盒，158元）适合送礼；家庭装（6枚起，79元起）适合自用。",
    "产地介绍": "被子垣生态有机果园位于五鹿山国家级自然保护区脚下，2016年建园，由中国农业大学科技小院提供技术支持。"
}

@server.list_tools()
async def list_tools() -> List[Tool]:
    return [
        Tool(
            name="auto_reply",
            description="根据用户问题自动生成回复",
            inputSchema={
                "type": "object",
                "properties": {
                    "farmer_id": {"type": "string", "description": "农户ID"},
                    "customer_message": {"type": "string", "description": "客户消息"},
                    "conversation_history": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "properties": {
                                "role": {"type": "string"},
                                "content": {"type": "string"}
                            }
                        },
                        "description": "对话历史"
                    }
                },
                "required": ["farmer_id", "customer_message"]
            }
        ),
        Tool(
            name="search_faq",
            description="搜索FAQ知识库",
            inputSchema={
                "type": "object",
                "properties": {
                    "query": {"type": "string", "description": "搜索关键词"}
                },
                "required": ["query"]
            }
        ),
        Tool(
            name="add_faq",
            description="添加FAQ条目",
            inputSchema={
                "type": "object",
                "properties": {
                    "farmer_id": {"type": "string", "description": "农户ID"},
                    "question": {"type": "string", "description": "问题"},
                    "answer": {"type": "string", "description": "答案"},
                    "category": {"type": "string", "description": "分类"}
                },
                "required": ["farmer_id", "question", "answer"]
            }
        ),
        Tool(
            name="transfer_to_human",
            description="转接人工客服",
            inputSchema={
                "type": "object",
                "properties": {
                    "farmer_id": {"type": "string", "description": "农户ID"},
                    "customer_id": {"type": "string", "description": "客户ID"},
                    "reason": {"type": "string", "description": "转接原因"},
                    "conversation_summary": {"type": "string", "description": "对话摘要"}
                },
                "required": ["farmer_id", "customer_id", "reason"]
            }
        ),
        Tool(
            name="get_product_recommendation",
            description="根据客户需求推荐产品",
            inputSchema={
                "type": "object",
                "properties": {
                    "farmer_id": {"type": "string", "description": "农户ID"},
                    "customer_need": {"type": "string", "description": "客户需求描述"},
                    "budget": {"type": "number", "description": "预算（可选）"},
                    "occasion": {"type": "string", "description": "用途场景：送礼/自用/企业采购"}
                },
                "required": ["farmer_id", "customer_need"]
            }
        )
    ]

@server.call_tool()
async def call_tool(name: str, arguments: dict) -> List[TextContent]:
    if name == "auto_reply":
        return await _auto_reply(arguments)
    elif name == "search_faq":
        return await _search_faq(arguments)
    elif name == "get_product_recommendation":
        return await _get_product_recommendation(arguments)
    # ... 其他工具实现

async def _auto_reply(args: dict) -> List[TextContent]:
    """智能自动回复"""
    customer_message = args["customer_message"]
    
    # 1. 先搜索FAQ
    faq_match = None
    for keyword, answer in FAQ_KNOWLEDGE_BASE.items():
        if keyword in customer_message:
            faq_match = answer
            break
    
    if faq_match:
        return [TextContent(type="text", text=json.dumps({
            "success": True,
            "reply": faq_match,
            "source": "faq",
            "confidence": 0.95
        }, ensure_ascii=False))]
    
    # 2. FAQ无匹配，使用LLM生成回复
    client = AsyncOpenAI(
        api_key="your-api-key",
        base_url="https://api.deepseek.com"  # 使用DeepSeek，性价比高
    )
    
    system_prompt = """你是智农链销平台的客服助手，代表山西蒲县被子垣有机果园回答客户问题。
    
产品信息：
- 玉露香梨：天地盖礼盒158元(9-12枚)，手提礼盒79元(6枚)
- 维纳斯黄金苹果：天地盖礼盒158元(12枚)，家庭装79-99元
- 蒲香红苹果：天地盖礼盒158元(9-12枚)
- 烟富苹果：天地盖礼盒158元(9-12枚)

特点：
- 产地：山西蒲县被子垣，北纬36度黄金果业带
- 认证：国家有机认证，不使用化肥农药
- 技术支持：中国农业大学科技小院
- 物流：顺丰冷链，1-2天发货，3-5天送达

回复要求：
1. 语气亲切友好
2. 回答准确专业
3. 适时推荐产品
4. 控制在100字以内"""

    conversation = args.get("conversation_history", [])
    messages = [{"role": "system", "content": system_prompt}]
    messages.extend(conversation)
    messages.append({"role": "user", "content": customer_message})
    
    response = await client.chat.completions.create(
        model="deepseek-chat",
        messages=messages,
        max_tokens=200,
        temperature=0.7
    )
    
    reply = response.choices[0].message.content
    
    return [TextContent(type="text", text=json.dumps({
        "success": True,
        "reply": reply,
        "source": "llm",
        "confidence": 0.8
    }, ensure_ascii=False))]

async def _get_product_recommendation(args: dict) -> List[TextContent]:
    """产品推荐"""
    need = args["customer_need"]
    budget = args.get("budget")
    occasion = args.get("occasion", "自用")
    
    recommendations = []
    
    if occasion == "送礼" or "送礼" in need or "礼盒" in need:
        recommendations.append({
            "product": "玉露香梨 天地盖礼盒",
            "price": 158,
            "reason": "高端大气的礼盒装，玉露香梨皮薄核小汁多，送礼首选",
            "spec": "9-12枚/盒，含箱净重约8斤"
        })
        recommendations.append({
            "product": "维纳斯黄金苹果 天地盖礼盒",
            "price": 158,
            "reason": "金黄色外皮，果肉细腻，寓意金玉满堂",
            "spec": "12枚/盒，含箱净重约6斤"
        })
    elif "实惠" in need or "家庭" in need or budget and budget < 100:
        recommendations.append({
            "product": "维纳斯黄金苹果 家庭装",
            "price": 79,
            "reason": "高性价比之选，全家享用",
            "spec": "12枚/箱，约5斤"
        })
        recommendations.append({
            "product": "玉露香梨 手提礼盒",
            "price": 79,
            "reason": "便携手提装，自用送人两相宜",
            "spec": "6枚/盒，约3斤"
        })
    else:
        # 默认推荐
        recommendations.append({
            "product": "玉露香梨 天地盖礼盒",
            "price": 158,
            "reason": "招牌产品，有机认证，口感最佳",
            "spec": "12枚/盒"
        })
    
    return [TextContent(type="text", text=json.dumps({
        "success": True,
        "recommendations": recommendations,
        "message": f"根据您的需求「{need}」，为您推荐以下产品"
    }, ensure_ascii=False))]

async def main():
    from mcp.server.stdio import stdio_server
    async with stdio_server() as (read_stream, write_stream):
        await server.run(read_stream, write_stream, server.create_initialization_options())

if __name__ == "__main__":
    asyncio.run(main())
```

---

## 三、MCPybarra服务生成流程

### 3.1 使用MCPybarra生成新MCP服务

```bash
# 1. 进入MCPybarra项目目录
cd /path/to/mcpybarra

# 2. 配置环境变量
export SWE_AGENT_MODEL=deepseek-chat  # 推荐使用DeepSeek，成本低

# 3. 运行单个服务生成
python framwork/run_langgraph_workflow.py \
    --user-input "创建一个农产品溯源MCP服务，功能包括：
    1. 生成溯源二维码：输入产品批次号，生成包含产地、采摘日期、农户信息的二维码
    2. 查询溯源信息：扫码后返回产品全链路信息
    3. 记录物流节点：支持添加发货、运输、签收等节点
    4. 支持产地：山西蒲县被子垣有机果园
    5. 数据库使用PostgreSQL" \
    --interactive

# 4. 批量生成多个服务
python framwork/batch_run_workflow.py \
    -i batch_inputs.txt \
    -n 3 \
    --swe-model deepseek-chat \
    --log-dir logs/agri_services
```

### 3.2 batch_inputs.txt 示例

```
创建一个农产品库存预警MCP服务，当库存低于阈值时自动发送微信通知，支持设置不同SKU的预警阈值，数据库使用PostgreSQL
创建一个农产品价格管理MCP服务，支持批量调价、促销定价、会员价设置，记录价格变更历史，支持按时间段查询
创建一个农产品销售数据统计MCP服务，支持按日/周/月统计销售额、订单量、客单价，生成报表，支持导出Excel
创建一个农产品物流查询MCP服务，对接顺丰/圆通/中通API，支持批量查询快递状态，异常物流自动预警
创建一个农产品评价管理MCP服务，支持评价采集、情感分析、自动回复好评、差评预警通知
```

### 3.3 生成成本估算

| 模型 | 单服务成本 | 质量评分 | 推荐场景 |
|------|-----------|----------|----------|
| DeepSeek-V3 | $0.018-0.03 | 82-85分 | 日常开发 |
| Qwen-Max | $0.03-0.05 | 83-86分 | 平衡之选 |
| GPT-4o | $0.08-0.14 | 85-89分 | 复杂场景 |
| Gemini-2.5-pro | $0.10-0.15 | 87-90分 | 最高质量 |

---

## 四、数据库设计

### 4.1 核心表结构

```sql
-- 农户表
CREATE TABLE farmers (
    farmer_id VARCHAR(32) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    phone VARCHAR(20) UNIQUE NOT NULL,
    id_card VARCHAR(18),
    address TEXT,
    cooperative_name VARCHAR(200),  -- 合作社名称
    bank_account VARCHAR(50),
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 商品表
CREATE TABLE products (
    product_id VARCHAR(32) PRIMARY KEY,
    farmer_id VARCHAR(32) REFERENCES farmers(farmer_id),
    name VARCHAR(200) NOT NULL,
    category VARCHAR(50) NOT NULL,
    description TEXT,
    fruit_type VARCHAR(50),
    origin VARCHAR(200) DEFAULT '山西蒲县被子垣',
    certification VARCHAR(100) DEFAULT '有机认证',
    images JSONB DEFAULT '[]',
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- SKU表
CREATE TABLE product_skus (
    sku_id VARCHAR(50) PRIMARY KEY,
    product_id VARCHAR(32) REFERENCES products(product_id),
    name VARCHAR(200) NOT NULL,
    fruit_type VARCHAR(50),
    package_type VARCHAR(50),
    grade VARCHAR(20),
    spec_per_box INTEGER,
    fruit_size VARCHAR(20),
    net_weight_with_box DECIMAL(10,2),
    net_weight_fruit DECIMAL(10,2),
    price DECIMAL(10,2) NOT NULL,
    cost_price DECIMAL(10,2),
    stock INTEGER DEFAULT 0,
    stock_warning_threshold INTEGER DEFAULT 10,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 订单表
CREATE TABLE orders (
    order_id VARCHAR(32) PRIMARY KEY,
    farmer_id VARCHAR(32) REFERENCES farmers(farmer_id),
    buyer_name VARCHAR(100) NOT NULL,
    buyer_phone VARCHAR(20) NOT NULL,
    shipping_address TEXT NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    shipping_fee DECIMAL(10,2) DEFAULT 0,
    discount_amount DECIMAL(10,2) DEFAULT 0,
    final_amount DECIMAL(10,2) NOT NULL,
    status VARCHAR(30) DEFAULT 'pending_payment',
    platform VARCHAR(30) NOT NULL,  -- taobao/pinduoduo/douyin/wechat/direct
    platform_order_id VARCHAR(100),
    tracking_number VARCHAR(100),
    shipping_company VARCHAR(50),
    remark TEXT,
    created_at TIMESTAMP DEFAULT NOW(),
    paid_at TIMESTAMP,
    shipped_at TIMESTAMP,
    completed_at TIMESTAMP
);

-- 订单明细表
CREATE TABLE order_items (
    item_id SERIAL PRIMARY KEY,
    order_id VARCHAR(32) REFERENCES orders(order_id),
    sku_id VARCHAR(50) REFERENCES product_skus(sku_id),
    product_name VARCHAR(200),
    sku_name VARCHAR(200),
    quantity INTEGER NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    subtotal DECIMAL(10,2) NOT NULL
);

-- 溯源记录表
CREATE TABLE traceability_records (
    trace_id VARCHAR(32) PRIMARY KEY,
    batch_number VARCHAR(50) UNIQUE NOT NULL,
    product_id VARCHAR(32) REFERENCES products(product_id),
    farmer_id VARCHAR(32) REFERENCES farmers(farmer_id),
    harvest_date DATE,
    harvest_location VARCHAR(200),
    certification_info JSONB,
    qr_code_url VARCHAR(500),
    logistics_nodes JSONB DEFAULT '[]',
    created_at TIMESTAMP DEFAULT NOW()
);

-- FAQ知识库表
CREATE TABLE faq_knowledge (
    faq_id SERIAL PRIMARY KEY,
    farmer_id VARCHAR(32) REFERENCES farmers(farmer_id),
    question TEXT NOT NULL,
    answer TEXT NOT NULL,
    category VARCHAR(50),
    keywords TSVECTOR,
    hit_count INTEGER DEFAULT 0,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT NOW()
);

-- 创建索引
CREATE INDEX idx_products_farmer ON products(farmer_id);
CREATE INDEX idx_products_category ON products(category);
CREATE INDEX idx_skus_product ON product_skus(product_id);
CREATE INDEX idx_orders_farmer ON orders(farmer_id);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_created ON orders(created_at);
CREATE INDEX idx_faq_keywords ON faq_knowledge USING GIN(keywords);
```

### 4.2 初始化蒲县产品数据

```sql
-- 插入农户（蒲县农业资源开发中心）
INSERT INTO farmers (farmer_id, name, phone, address, cooperative_name) VALUES
('FARMER_PUXI_001', '蒲县农业资源开发中心', '13661109823', '山西省临汾市蒲县蒲城镇太夫村', '被子垣生态有机果园');

-- 插入商品
INSERT INTO products (product_id, farmer_id, name, category, description, fruit_type) VALUES
('PRD_YLX_001', 'FARMER_PUXI_001', '有机玉露香梨', '有机水果', '皮薄核小、汁多味甜，来自北纬36度黄金果业带', '玉露香梨'),
('PRD_WNS_001', 'FARMER_PUXI_001', '维纳斯黄金苹果', '有机水果', '金黄诱人、果肉细腻，有机认证', '维纳斯苹果'),
('PRD_PXH_001', 'FARMER_PUXI_001', '有机蒲香红苹果', '有机水果', '色泽红润、脆甜可口，可加工苹果脆片', '蒲香红'),
('PRD_YF_001', 'FARMER_PUXI_001', '有机烟富苹果', '有机水果', '经典红富士口感，有机种植', '烟富');

-- 插入SKU（根据Excel定价表）
INSERT INTO product_skus (sku_id, product_id, name, fruit_type, package_type, grade, spec_per_box, fruit_size, net_weight_with_box, net_weight_fruit, price, stock) VALUES
-- 玉露香梨
('SKU_YLX_001', 'PRD_YLX_001', '玉露香梨-天地盖礼盒-9枚装', '玉露香梨', '天地盖礼盒', '一级', 9, '85-95', 8.3, 6.5, 158, 100),
('SKU_YLX_002', 'PRD_YLX_001', '玉露香梨-天地盖礼盒-12枚装', '玉露香梨', '天地盖礼盒', '一级', 12, '80-90', 8.8, 7.0, 158, 100),
('SKU_YLX_003', 'PRD_YLX_001', '玉露香梨-手提礼盒-6枚装', '玉露香梨', '手提礼盒', '二级', 6, '80-90', 4.5, 3.2, 79, 200),
-- 维纳斯苹果
('SKU_WNS_001', 'PRD_WNS_001', '维纳斯苹果-天地盖礼盒-12枚装', '维纳斯苹果', '天地盖礼盒', '一级', 12, '75-80', 6.3, 4.5, 158, 100),
('SKU_WNS_002', 'PRD_WNS_001', '维纳斯苹果-家庭装-小', '维纳斯苹果', '对开箱子', '不套袋', 12, '65-75', 5.9, 4.5, 79, 200),
('SKU_WNS_003', 'PRD_WNS_001', '维纳斯苹果-家庭装-大', '维纳斯苹果', '对开箱子', '不套袋', 24, '65-75', 9.4, 8.0, 99, 150),
-- 蒲香红
('SKU_PXH_001', 'PRD_PXH_001', '蒲香红-天地盖礼盒-9枚装', '蒲香红', '天地盖礼盒', '一级', 9, '85-95', 7.8, 6.0, 158, 100),
('SKU_PXH_002', 'PRD_PXH_001', '蒲香红-天地盖礼盒-12枚装', '蒲香红', '天地盖礼盒', '一级', 12, '85-95', 8.3, 6.5, 158, 100),
-- 烟富
('SKU_YF_001', 'PRD_YF_001', '烟富苹果-天地盖礼盒-9枚装', '烟富', '天地盖礼盒', '一级', 9, '85-95', 6.8, 5.0, 158, 100),
('SKU_YF_002', 'PRD_YF_001', '烟富苹果-天地盖礼盒-12枚装', '烟富', '天地盖礼盒', '一级', 12, '80-90', 6.8, 5.0, 158, 100);
```

---

## 五、API网关设计

### 5.1 FastAPI网关实现

```python
# api_gateway/main.py
"""
API网关 - 统一入口、认证、路由、限流
"""

import json
import asyncio
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from contextlib import asynccontextmanager

from fastapi import FastAPI, HTTPException, Depends, Request, Header
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel
import redis.asyncio as redis
import jwt
import httpx

# ============ 配置 ============

class Settings:
    JWT_SECRET = "your-jwt-secret-key-change-in-production"
    JWT_ALGORITHM = "HS256"
    JWT_EXPIRE_HOURS = 24
    REDIS_URL = "redis://localhost:6379"
    RATE_LIMIT_REQUESTS = 100  # 每分钟请求数
    RATE_LIMIT_WINDOW = 60  # 秒
    
    # MCP服务端口映射
    MCP_SERVICES = {
        "product": "http://localhost:8001",
        "order": "http://localhost:8002",
        "customer-service": "http://localhost:8003",
        "inventory": "http://localhost:8004",
        "traceability": "http://localhost:8005",
        "analytics": "http://localhost:8006",
    }

settings = Settings()

# ============ 初始化 ============

@asynccontextmanager
async def lifespan(app: FastAPI):
    # 启动时
    app.state.redis = redis.from_url(settings.REDIS_URL)
    app.state.http_client = httpx.AsyncClient(timeout=30.0)
    yield
    # 关闭时
    await app.state.redis.close()
    await app.state.http_client.aclose()

app = FastAPI(
    title="智农链销 API Gateway",
    description="农产品电商AI赋能平台API网关",
    version="1.0.0",
    lifespan=lifespan
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

security = HTTPBearer()

# ============ 认证模块 ============

class TokenPayload(BaseModel):
    farmer_id: str
    phone: str
    exp: datetime

class LoginRequest(BaseModel):
    phone: str
    code: str  # 验证码

class LoginResponse(BaseModel):
    access_token: str
    token_type: str = "bearer"
    farmer_id: str
    expires_in: int

def create_token(farmer_id: str, phone: str) -> str:
    expire = datetime.utcnow() + timedelta(hours=settings.JWT_EXPIRE_HOURS)
    payload = {
        "farmer_id": farmer_id,
        "phone": phone,
        "exp": expire
    }
    return jwt.encode(payload, settings.JWT_SECRET, algorithm=settings.JWT_ALGORITHM)

def verify_token(token: str) -> TokenPayload:
    try:
        payload = jwt.decode(token, settings.JWT_SECRET, algorithms=[settings.JWT_ALGORITHM])
        return TokenPayload(**payload)
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token已过期")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="无效的Token")

async def get_current_farmer(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> TokenPayload:
    return verify_token(credentials.credentials)

# ============ 限流模块 ============

async def rate_limit(request: Request, farmer_id: str):
    """滑动窗口限流"""
    redis_client = request.app.state.redis
    key = f"rate_limit:{farmer_id}"
    
    now = datetime.now().timestamp()
    window_start = now - settings.RATE_LIMIT_WINDOW
    
    # 移除过期记录
    await redis_client.zremrangebyscore(key, 0, window_start)
    
    # 获取当前窗口请求数
    count = await redis_client.zcard(key)
    
    if count >= settings.RATE_LIMIT_REQUESTS:
        raise HTTPException(status_code=429, detail="请求过于频繁，请稍后再试")
    
    # 记录本次请求
    await redis_client.zadd(key, {str(now): now})
    await redis_client.expire(key, settings.RATE_LIMIT_WINDOW)

# ============ MCP服务调用 ============

class MCPRequest(BaseModel):
    service: str  # product/order/customer-service/...
    tool: str     # 工具名称
    arguments: Dict[str, Any]

class MCPResponse(BaseModel):
    success: bool
    data: Optional[Any] = None
    error: Optional[str] = None

async def call_mcp_service(
    http_client: httpx.AsyncClient,
    service: str,
    tool: str,
    arguments: dict
) -> dict:
    """调用MCP服务"""
    if service not in settings.MCP_SERVICES:
        raise HTTPException(status_code=400, detail=f"未知服务: {service}")
    
    base_url = settings.MCP_SERVICES[service]
    
    # MCP协议的JSON-RPC调用
    rpc_request = {
        "jsonrpc": "2.0",
        "id": 1,
        "method": "tools/call",
        "params": {
            "name": tool,
            "arguments": arguments
        }
    }
    
    try:
        response = await http_client.post(
            f"{base_url}/mcp",
            json=rpc_request,
            headers={"Content-Type": "application/json"}
        )
        response.raise_for_status()
        result = response.json()
        
        if "error" in result:
            return {"success": False, "error": result["error"]["message"]}
        
        # 解析MCP响应
        content = result.get("result", {}).get("content", [])
        if content and content[0].get("type") == "text":
            return json.loads(content[0]["text"])
        
        return {"success": True, "data": result}
        
    except httpx.HTTPError as e:
        return {"success": False, "error": f"服务调用失败: {str(e)}"}

# ============ API路由 ============

@app.post("/api/v1/login", response_model=LoginResponse)
async def login(request: LoginRequest):
    """农户登录（验证码登录）"""
    # TODO: 实际项目中需要验证短信验证码
    # 这里简化处理
    
    # 查询农户信息
    farmer_id = f"FARMER_{request.phone[-4:]}"  # 简化ID生成
    
    token = create_token(farmer_id, request.phone)
    
    return LoginResponse(
        access_token=token,
        farmer_id=farmer_id,
        expires_in=settings.JWT_EXPIRE_HOURS * 3600
    )

@app.post("/api/v1/mcp/call", response_model=MCPResponse)
async def mcp_call(
    request: Request,
    mcp_request: MCPRequest,
    current_farmer: TokenPayload = Depends(get_current_farmer)
):
    """统一MCP服务调用入口"""
    # 限流检查
    await rate_limit(request, current_farmer.farmer_id)
    
    # 注入farmer_id到参数中
    arguments = mcp_request.arguments.copy()
    if "farmer_id" not in arguments:
        arguments["farmer_id"] = current_farmer.farmer_id
    
    # 调用MCP服务
    result = await call_mcp_service(
        request.app.state.http_client,
        mcp_request.service,
        mcp_request.tool,
        arguments
    )
    
    return MCPResponse(**result)

# ============ 便捷API（封装常用操作）============

@app.get("/api/v1/products")
async def list_products(
    request: Request,
    category: Optional[str] = None,
    fruit_type: Optional[str] = None,
    page: int = 1,
    page_size: int = 20,
    current_farmer: TokenPayload = Depends(get_current_farmer)
):
    """获取商品列表"""
    await rate_limit(request, current_farmer.farmer_id)
    
    return await call_mcp_service(
        request.app.state.http_client,
        "product",
        "list_products",
        {
            "farmer_id": current_farmer.farmer_id,
            "category": category,
            "fruit_type": fruit_type,
            "page": page,
            "page_size": page_size
        }
    )

@app.get("/api/v1/products/{product_id}")
async def get_product(
    request: Request,
    product_id: str,
    current_farmer: TokenPayload = Depends(get_current_farmer)
):
    """获取商品详情"""
    await rate_limit(request, current_farmer.farmer_id)
    
    return await call_mcp_service(
        request.app.state.http_client,
        "product",
        "get_product",
        {"product_id": product_id}
    )

@app.get("/api/v1/orders")
async def list_orders(
    request: Request,
    status: Optional[str] = None,
    platform: Optional[str] = None,
    page: int = 1,
    page_size: int = 20,
    current_farmer: TokenPayload = Depends(get_current_farmer)
):
    """获取订单列表"""
    await rate_limit(request, current_farmer.farmer_id)
    
    return await call_mcp_service(
        request.app.state.http_client,
        "order",
        "list_orders",
        {
            "farmer_id": current_farmer.farmer_id,
            "status": status,
            "platform": platform,
            "page": page,
            "page_size": page_size
        }
    )

@app.post("/api/v1/orders/{order_id}/ship")
async def ship_order(
    request: Request,
    order_id: str,
    tracking_number: str,
    shipping_company: str = "顺丰速运",
    current_farmer: TokenPayload = Depends(get_current_farmer)
):
    """订单发货"""
    await rate_limit(request, current_farmer.farmer_id)
    
    return await call_mcp_service(
        request.app.state.http_client,
        "order",
        "ship_order",
        {
            "order_id": order_id,
            "tracking_number": tracking_number,
            "shipping_company": shipping_company
        }
    )

@app.post("/api/v1/customer-service/chat")
async def customer_service_chat(
    request: Request,
    message: str,
    conversation_history: Optional[list] = None,
    current_farmer: TokenPayload = Depends(get_current_farmer)
):
    """智能客服对话"""
    await rate_limit(request, current_farmer.farmer_id)
    
    return await call_mcp_service(
        request.app.state.http_client,
        "customer-service",
        "auto_reply",
        {
            "farmer_id": current_farmer.farmer_id,
            "customer_message": message,
            "conversation_history": conversation_history or []
        }
    )

@app.get("/api/v1/inventory/warnings")
async def get_inventory_warnings(
    request: Request,
    threshold: int = 10,
    current_farmer: TokenPayload = Depends(get_current_farmer)
):
    """获取库存预警"""
    await rate_limit(request, current_farmer.farmer_id)
    
    return await call_mcp_service(
        request.app.state.http_client,
        "product",
        "get_low_stock_skus",
        {
            "farmer_id": current_farmer.farmer_id,
            "threshold": threshold
        }
    )

# ============ 健康检查 ============

@app.get("/health")
async def health_check():
    return {"status": "healthy", "timestamp": datetime.now().isoformat()}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 六、前端模板设计

### 6.1 项目结构

```
frontend/
├── packages/
│   ├── farmer-admin/          # 农户管理后台 (Vue3 + Element Plus)
│   │   ├── src/
│   │   │   ├── views/
│   │   │   │   ├── dashboard/     # 数据概览
│   │   │   │   ├── products/      # 商品管理
│   │   │   │   ├── orders/        # 订单管理
│   │   │   │   ├── inventory/     # 库存管理
│   │   │   │   ├── customer/      # 客户服务
│   │   │   │   └── settings/      # 系统设置
│   │   │   ├── components/
│   │   │   ├── api/
│   │   │   ├── stores/
│   │   │   └── utils/
│   │   └── package.json
│   │
│   ├── mini-program/          # 小程序 (uni-app)
│   │   ├── pages/
│   │   │   ├── index/         # 首页
│   │   │   ├── category/      # 分类
│   │   │   ├── product/       # 商品详情
│   │   │   ├── cart/          # 购物车
│   │   │   ├── order/         # 订单
│   │   │   └── user/          # 用户中心
│   │   └── package.json
│   │
│   └── shared/                # 共享代码
│       ├── api/               # API封装
│       ├── types/             # TypeScript类型
│       └── utils/             # 工具函数
│
├── pnpm-workspace.yaml
└── package.json
```

### 6.2 API封装 (TypeScript)

```typescript
// packages/shared/api/mcp-client.ts
import axios, { AxiosInstance } from 'axios';

export interface MCPResponse<T = any> {
  success: boolean;
  data?: T;
  error?: string;
}

export interface MCPRequest {
  service: string;
  tool: string;
  arguments: Record<string, any>;
}

export class MCPClient {
  private http: AxiosInstance;
  
  constructor(baseURL: string = '/api/v1') {
    this.http = axios.create({
      baseURL,
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json',
      },
    });
    
    // 请求拦截器 - 添加Token
    this.http.interceptors.request.use((config) => {
      const token = localStorage.getItem('access_token');
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    });
    
    // 响应拦截器 - 统一错误处理
    this.http.interceptors.response.use(
      (response) => response.data,
      (error) => {
        if (error.response?.status === 401) {
          localStorage.removeItem('access_token');
          window.location.href = '/login';
        }
        return Promise.reject(error);
      }
    );
  }
  
  // 通用MCP调用
  async call<T>(request: MCPRequest): Promise<MCPResponse<T>> {
    return this.http.post('/mcp/call', request);
  }
  
  // ============ 商品管理 ============
  
  async listProducts(params: {
    category?: string;
    fruitType?: string;
    page?: number;
    pageSize?: number;
  }) {
    return this.http.get('/products', { params });
  }
  
  async getProduct(productId: string) {
    return this.http.get(`/products/${productId}`);
  }
  
  async createProduct(data: {
    name: string;
    category: string;
    description: string;
    fruitType: string;
    skus: Array<{
      packageType: string;
      grade: string;
      specPerBox: number;
      fruitSize: string;
      price: number;
      stock: number;
    }>;
  }) {
    return this.call({
      service: 'product',
      tool: 'create_product',
      arguments: data,
    });
  }
  
  async updateSkuStock(skuId: string, stockChange: number) {
    return this.call({
      service: 'product',
      tool: 'update_sku_stock',
      arguments: { sku_id: skuId, stock_change: stockChange },
    });
  }
  
  // ============ 订单管理 ============
  
  async listOrders(params: {
    status?: string;
    platform?: string;
    startDate?: string;
    endDate?: string;
    page?: number;
    pageSize?: number;
  }) {
    return this.http.get('/orders', { params });
  }
  
  async shipOrder(orderId: string, trackingNumber: string, shippingCompany: string = '顺丰速运') {
    return this.http.post(`/orders/${orderId}/ship`, {
      tracking_number: trackingNumber,
      shipping_company: shippingCompany,
    });
  }
  
  // ============ 客服 ============
  
  async chat(message: string, history?: Array<{role: string; content: string}>) {
    return this.http.post('/customer-service/chat', {
      message,
      conversation_history: history,
    });
  }
  
  // ============ 库存预警 ============
  
  async getInventoryWarnings(threshold: number = 10) {
    return this.http.get('/inventory/warnings', { params: { threshold } });
  }
}

export const mcpClient = new MCPClient();
```

### 6.3 农户后台示例页面

```vue
<!-- packages/farmer-admin/src/views/orders/OrderList.vue -->
<template>
  <div class="order-list">
    <!-- 筛选栏 -->
    <el-card class="filter-card">
      <el-form :inline="true" :model="filters">
        <el-form-item label="订单状态">
          <el-select v-model="filters.status" placeholder="全部" clearable>
            <el-option label="待付款" value="pending_payment" />
            <el-option label="待发货" value="pending_shipment" />
            <el-option label="已发货" value="shipped" />
            <el-option label="已完成" value="completed" />
            <el-option label="已取消" value="cancelled" />
          </el-select>
        </el-form-item>
        <el-form-item label="来源平台">
          <el-select v-model="filters.platform" placeholder="全部" clearable>
            <el-option label="淘宝" value="taobao" />
            <el-option label="拼多多" value="pinduoduo" />
            <el-option label="抖音" value="douyin" />
            <el-option label="微信" value="wechat" />
            <el-option label="直营" value="direct" />
          </el-select>
        </el-form-item>
        <el-form-item label="日期范围">
          <el-date-picker
            v-model="filters.dateRange"
            type="daterange"
            range-separator="至"
            start-placeholder="开始日期"
            end-placeholder="结束日期"
          />
        </el-form-item>
        <el-form-item>
          <el-button type="primary" @click="fetchOrders">查询</el-button>
          <el-button @click="resetFilters">重置</el-button>
        </el-form-item>
      </el-form>
    </el-card>
    
    <!-- 订单列表 -->
    <el-card class="list-card">
      <el-table :data="orders" v-loading="loading" stripe>
        <el-table-column prop="order_id" label="订单号" width="150" />
        <el-table-column prop="buyer_name" label="买家" width="100" />
        <el-table-column prop="buyer_phone" label="电话" width="120" />
        <el-table-column label="商品" min-width="200">
          <template #default="{ row }">
            <div v-for="item in row.items" :key="item.sku_id" class="order-item">
              {{ item.product_name }} × {{ item.quantity }}
            </div>
          </template>
        </el-table-column>
        <el-table-column prop="final_amount" label="金额" width="100">
          <template #default="{ row }">
            ¥{{ row.final_amount }}
          </template>
        </el-table-column>
        <el-table-column prop="platform" label="平台" width="80">
          <template #default="{ row }">
            <el-tag :type="platformTagType(row.platform)">
              {{ platformLabel(row.platform) }}
            </el-tag>
          </template>
        </el-table-column>
        <el-table-column prop="status" label="状态" width="100">
          <template #default="{ row }">
            <el-tag :type="statusTagType(row.status)">
              {{ statusLabel(row.status) }}
            </el-tag>
          </template>
        </el-table-column>
        <el-table-column prop="created_at" label="下单时间" width="160" />
        <el-table-column label="操作" width="150" fixed="right">
          <template #default="{ row }">
            <el-button 
              v-if="row.status === 'pending_shipment'"
              type="primary" 
              size="small"
              @click="openShipDialog(row)"
            >
              发货
            </el-button>
            <el-button size="small" @click="viewDetail(row)">详情</el-button>
          </template>
        </el-table-column>
      </el-table>
      
      <!-- 分页 -->
      <el-pagination
        v-model:current-page="pagination.page"
        v-model:page-size="pagination.pageSize"
        :total="pagination.total"
        :page-sizes="[10, 20, 50, 100]"
        layout="total, sizes, prev, pager, next, jumper"
        @size-change="fetchOrders"
        @current-change="fetchOrders"
      />
    </el-card>
    
    <!-- 发货弹窗 -->
    <el-dialog v-model="shipDialog.visible" title="订单发货" width="500px">
      <el-form :model="shipDialog.form" label-width="100px">
        <el-form-item label="订单号">
          {{ shipDialog.order?.order_id }}
        </el-form-item>
        <el-form-item label="收货地址">
          {{ shipDialog.order?.shipping_address }}
        </el-form-item>
        <el-form-item label="快递公司" required>
          <el-select v-model="shipDialog.form.shippingCompany">
            <el-option label="顺丰速运" value="顺丰速运" />
            <el-option label="圆通速递" value="圆通速递" />
            <el-option label="中通快递" value="中通快递" />
            <el-option label="韵达快递" value="韵达快递" />
          </el-select>
        </el-form-item>
        <el-form-item label="快递单号" required>
          <el-input v-model="shipDialog.form.trackingNumber" placeholder="请输入快递单号" />
        </el-form-item>
      </el-form>
      <template #footer>
        <el-button @click="shipDialog.visible = false">取消</el-button>
        <el-button type="primary" @click="confirmShip" :loading="shipDialog.loading">
          确认发货
        </el-button>
      </template>
    </el-dialog>
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, onMounted } from 'vue';
import { ElMessage } from 'element-plus';
import { mcpClient } from '@/api/mcp-client';

// 状态
const loading = ref(false);
const orders = ref([]);

const filters = reactive({
  status: '',
  platform: '',
  dateRange: null as [Date, Date] | null,
});

const pagination = reactive({
  page: 1,
  pageSize: 20,
  total: 0,
});

const shipDialog = reactive({
  visible: false,
  loading: false,
  order: null as any,
  form: {
    shippingCompany: '顺丰速运',
    trackingNumber: '',
  },
});

// 方法
const fetchOrders = async () => {
  loading.value = true;
  try {
    const params: any = {
      page: pagination.page,
      pageSize: pagination.pageSize,
    };
    if (filters.status) params.status = filters.status;
    if (filters.platform) params.platform = filters.platform;
    if (filters.dateRange) {
      params.startDate = filters.dateRange[0].toISOString().split('T')[0];
      params.endDate = filters.dateRange[1].toISOString().split('T')[0];
    }
    
    const res = await mcpClient.listOrders(params);
    if (res.success) {
      orders.value = res.data;
      pagination.total = res.pagination.total;
    }
  } catch (error) {
    ElMessage.error('获取订单列表失败');
  } finally {
    loading.value = false;
  }
};

const openShipDialog = (order: any) => {
  shipDialog.order = order;
  shipDialog.form.trackingNumber = '';
  shipDialog.visible = true;
};

const confirmShip = async () => {
  if (!shipDialog.form.trackingNumber) {
    ElMessage.warning('请输入快递单号');
    return;
  }
  
  shipDialog.loading = true;
  try {
    const res = await mcpClient.shipOrder(
      shipDialog.order.order_id,
      shipDialog.form.trackingNumber,
      shipDialog.form.shippingCompany
    );
    
    if (res.success) {
      ElMessage.success('发货成功');
      shipDialog.visible = false;
      fetchOrders();
    } else {
      ElMessage.error(res.error || '发货失败');
    }
  } catch (error) {
    ElMessage.error('发货失败');
  } finally {
    shipDialog.loading = false;
  }
};

const resetFilters = () => {
  filters.status = '';
  filters.platform = '';
  filters.dateRange = null;
  pagination.page = 1;
  fetchOrders();
};

const statusLabel = (status: string) => {
  const map: Record<string, string> = {
    pending_payment: '待付款',
    paid: '已付款',
    pending_shipment: '待发货',
    shipped: '已发货',
    delivered: '已送达',
    completed: '已完成',
    cancelled: '已取消',
  };
  return map[status] || status;
};

const statusTagType = (status: string) => {
  const map: Record<string, string> = {
    pending_payment: 'warning',
    pending_shipment: 'danger',
    shipped: 'primary',
    completed: 'success',
    cancelled: 'info',
  };
  return map[status] || '';
};

const platformLabel = (platform: string) => {
  const map: Record<string, string> = {
    taobao: '淘宝',
    pinduoduo: '拼多多',
    douyin: '抖音',
    wechat: '微信',
    direct: '直营',
  };
  return map[platform] || platform;
};

const platformTagType = (platform: string) => {
  const map: Record<string, string> = {
    taobao: 'warning',
    pinduoduo: 'danger',
    douyin: '',
    wechat: 'success',
    direct: 'info',
  };
  return map[platform] || '';
};

const viewDetail = (order: any) => {
  // TODO: 跳转订单详情页
};

onMounted(() => {
  fetchOrders();
});
</script>

<style scoped>
.filter-card {
  margin-bottom: 16px;
}

.list-card {
  .order-item {
    font-size: 12px;
    line-height: 1.5;
  }
}

.el-pagination {
  margin-top: 16px;
  justify-content: flex-end;
}
</style>
```

---

## 七、部署方案

### 7.1 Docker Compose配置

```yaml
# docker-compose.yml
version: '3.8'

services:
  # PostgreSQL数据库
  postgres:
    image: postgres:16-alpine
    container_name: zhinong_postgres
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: zhinonglianxiao
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis缓存
  redis:
    image: redis:7-alpine
    container_name: zhinong_redis
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # MinIO文件存储
  minio:
    image: minio/minio:latest
    container_name: zhinong_minio
    command: server /data --console-address ":9001"
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadmin123
    volumes:
      - minio_data:/data
    ports:
      - "9000:9000"
      - "9001:9001"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3

  # API网关
  api-gateway:
    build:
      context: ./api_gateway
      dockerfile: Dockerfile
    container_name: zhinong_api_gateway
    environment:
      - DATABASE_URL=postgresql://postgres:postgres@postgres:5432/zhinonglianxiao
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=your-jwt-secret-change-in-production
    ports:
      - "8000:8000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped

  # MCP服务 - 商品管理
  mcp-product:
    build:
      context: ./mcp_servers/product_management
      dockerfile: Dockerfile
    container_name: zhinong_mcp_product
    environment:
      - DATABASE_URL=postgresql://postgres:postgres@postgres:5432/zhinonglianxiao
    ports:
      - "8001:8001"
    depends_on:
      postgres:
        condition: service_healthy
    restart: unless-stopped

  # MCP服务 - 订单管理
  mcp-order:
    build:
      context: ./mcp_servers/order_management
      dockerfile: Dockerfile
    container_name: zhinong_mcp_order
    environment:
      - DATABASE_URL=postgresql://postgres:postgres@postgres:5432/zhinonglianxiao
    ports:
      - "8002:8002"
    depends_on:
      postgres:
        condition: service_healthy
    restart: unless-stopped

  # MCP服务 - 智能客服
  mcp-customer-service:
    build:
      context: ./mcp_servers/smart_customer_service
      dockerfile: Dockerfile
    container_name: zhinong_mcp_customer_service
    environment:
      - DATABASE_URL=postgresql://postgres:postgres@postgres:5432/zhinonglianxiao
      - DEEPSEEK_API_KEY=${DEEPSEEK_API_KEY}
    ports:
      - "8003:8003"
    depends_on:
      postgres:
        condition: service_healthy
    restart: unless-stopped

  # 农户后台前端
  farmer-admin:
    build:
      context: ./frontend/packages/farmer-admin
      dockerfile: Dockerfile
    container_name: zhinong_farmer_admin
    ports:
      - "3000:80"
    depends_on:
      - api-gateway
    restart: unless-stopped

  # Nginx反向代理
  nginx:
    image: nginx:alpine
    container_name: zhinong_nginx
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - api-gateway
      - farmer-admin
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
  minio_data:

networks:
  default:
    name: zhinong_network
```

### 7.2 MCP服务Dockerfile

```dockerfile
# mcp_servers/product_management/Dockerfile
FROM python:3.11-slim

WORKDIR /app

# 安装依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制代码
COPY . .

# 暴露端口
EXPOSE 8001

# 启动命令
CMD ["python", "-m", "uvicorn", "http_server:app", "--host", "0.0.0.0", "--port", "8001"]
```

### 7.3 Nginx配置

```nginx
# nginx/nginx.conf
events {
    worker_connections 1024;
}

http {
    upstream api_gateway {
        server api-gateway:8000;
    }
    
    upstream farmer_admin {
        server farmer-admin:80;
    }
    
    server {
        listen 80;
        server_name zhinonglianxiao.com;
        
        # 重定向到HTTPS
        return 301 https://$server_name$request_uri;
    }
    
    server {
        listen 443 ssl http2;
        server_name zhinonglianxiao.com;
        
        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;
        
        # API请求
        location /api/ {
            proxy_pass http://api_gateway;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
        
        # 农户后台
        location / {
            proxy_pass http://farmer_admin;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
    }
}
```

### 7.4 启动命令

```bash
# 1. 克隆项目
git clone https://github.com/your-org/zhinonglianxiao.git
cd zhinonglianxiao

# 2. 配置环境变量
cp .env.example .env
# 编辑.env文件，填写API密钥等

# 3. 启动所有服务
docker-compose up -d

# 4. 查看日志
docker-compose logs -f

# 5. 初始化数据库（首次运行）
docker-compose exec postgres psql -U postgres -d zhinonglianxiao -f /init.sql

# 6. 访问
# 农户后台: https://zhinonglianxiao.com
# API文档: https://zhinonglianxiao.com/api/docs
```

---

## 八、项目目录结构

```
zhinonglianxiao/
├── README.md
├── docker-compose.yml
├── .env.example
├── init.sql                    # 数据库初始化脚本
│
├── api_gateway/                # API网关
│   ├── main.py
│   ├── requirements.txt
│   └── Dockerfile
│
├── mcp_servers/                # MCP服务集群
│   ├── product_management/
│   │   ├── server.py
│   │   ├── http_server.py      # HTTP包装器
│   │   ├── requirements.txt
│   │   └── Dockerfile
│   ├── order_management/
│   ├── smart_customer_service/
│   ├── inventory_management/
│   ├── traceability/
│   └── analytics/
│
├── mcpybarra/                  # MCPybarra生成引擎
│   ├── framwork/
│   │   ├── run_langgraph_workflow.py
│   │   ├── batch_run_workflow.py
│   │   ├── logger.py
│   │   └── schema.py
│   ├── batch_inputs.txt
│   └── workspace/              # 生成的服务输出目录
│
├── frontend/                   # 前端项目
│   ├── packages/
│   │   ├── farmer-admin/       # 农户后台
│   │   ├── mini-program/       # 小程序
│   │   └── shared/             # 共享代码
│   ├── pnpm-workspace.yaml
│   └── package.json
│
├── nginx/                      # Nginx配置
│   ├── nginx.conf
│   └── ssl/
│
├── docs/                       # 文档
│   ├── API.md
│   ├── DEPLOYMENT.md
│   └── DEVELOPMENT.md
│
└── scripts/                    # 运维脚本
    ├── backup.sh
    ├── deploy.sh
    └── monitor.sh
```

---

## 九、开发计划（MVP）

### 阶段一：核心功能（2周）
- [ ] 数据库设计与初始化
- [ ] 商品管理MCP服务
- [ ] 订单管理MCP服务
- [ ] API网关基础版
- [ ] 农户后台登录/商品/订单页面

### 阶段二：增值功能（2周）
- [ ] 智能客服MCP服务
- [ ] 库存预警MCP服务
- [ ] 溯源追踪MCP服务
- [ ] 数据统计MCP服务

### 阶段三：平台对接（2周）
- [ ] 淘宝开放平台对接
- [ ] 拼多多开放平台对接
- [ ] 抖音电商对接
- [ ] 微信小程序商城

### 阶段四：优化上线（1周）
- [ ] 性能优化
- [ ] 安全加固
- [ ] 部署上线
- [ ] 用户培训

---

## 十、关键技术要点

1. **MCP服务设计原则**
   - 单一职责：每个服务专注一个领域
   - 工具粒度适中：不要太细也不要太粗
   - 参数扁平化：方便LLM调用
   - 返回结构化JSON：便于前端解析

2. **MCPybarra使用技巧**
   - 需求描述要详细具体
   - 指定数据库类型和关键表结构
   - 使用DeepSeek-V3降低成本
   - 批量生成提高效率

3. **部署注意事项**
   - 使用Docker容器化部署
   - 配置健康检查和自动重启
   - 设置合理的资源限制
   - 配置HTTPS和防火墙

---

*文档版本: 1.0.0*
*更新日期: 2025-01-23*
*作者: 智农链销技术团队*